using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace EfNavGuard;

[Generator]
public class EfNavGuardGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{SourceGenHelpers.MarkerAttributeName}.g.cs",
            SourceText.From(SourceGenHelpers.GuardedNavigationAttributeCode, Encoding.UTF8)));

        var generatorOptions = context.CompilationProvider
            .Select((c, _) =>
            {
                if (c is not CSharpCompilation compilation)
                {
                    return null;
                }

                return new GeneratorOptions(compilation.Options.NullableContextOptions == NullableContextOptions.Enable, (int)compilation.LanguageVersion);
            });

        var propertiesToAugment = context.SyntaxProvider.ForAttributeWithMetadataName
            (
                fullyQualifiedMetadataName: $"EfNavGuard.{SourceGenHelpers.MarkerAttributeName}",
                predicate: static (node, _) => IsValidSyntaxNodeForAugmentation(node),
                transform: static (syntaxCtx, _) => TransformPropertyDeclaration(syntaxCtx)
            )
            .Where(x => x is not null);

        var propertiesAndOptions = propertiesToAugment.Combine(generatorOptions);

        context.RegisterSourceOutput(propertiesAndOptions, Generate!);
    }

    private static void Generate(SourceProductionContext ctx, (PropertyAugmentationData AugmentationData, GeneratorOptions? Options) args)
    {
        var (augmentationData, options) = args;

        // Project is not csharp project?
        if (options is null)
        {
            return;
        }

        // Do nothing if C# version is lower than 13.0 (partial properties were introduced in C# 13.0)
        if (options.LanguageVersion < 1300)
        {
            return;
        }

        var propertyName = augmentationData.PropertyNameStr;
        var propertyFullType = augmentationData.PropertyFullTypeStr;
        var containingTypeName = augmentationData.ContainingTypeNameStr;
        var namespaceName = augmentationData.NamespaceNameStr;
        var fileName = augmentationData.FileName;
        var backingFieldName = $"_{augmentationData.PropertyNameStr}";
        var backingFieldType = $"{augmentationData.PropertyFullTypeStr}{(options.NullableEnabled ? "?" : string.Empty)}";
        var propertyInitializer = augmentationData.PropertyInitializer;

        var sb = new IndentedStringBuilder();
        sb.AppendLine
        (
            """
            // <auto-generated>
            // This code was generated by a tool, any changes made to it will be lost.
            // </auto-generated>
            """
        );

        if (options.NullableEnabled)
        {
            sb.AppendLine("#nullable enable");
        }

        if (namespaceName != SourceGenHelpers.GlobalNamespaceName)
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.IncrementIndent();
        }

        sb.AppendLine($"partial class {containingTypeName}");
        sb.AppendLine("{");
        sb.IncrementIndent();
        sb.AppendLine($"private {backingFieldType} {backingFieldName};");
        sb.AppendLine();
        sb.AppendLine($"public partial {propertyFullType} {propertyName}");
        sb.AppendLine("{");
        sb.IncrementIndent();
        sb.AppendLine($"get => {backingFieldName} ?? throw new System.InvalidOperationException(\"{propertyName} was not loaded. Make sure to include it in the query.\");");
        sb.AppendLine($"{propertyInitializer} => {backingFieldName} = value;");
        sb.DecrementIndent();
        sb.AppendLine("}");
        sb.DecrementIndent();
        sb.AppendLine("}");

        if (namespaceName != SourceGenHelpers.GlobalNamespaceName)
        {
            sb.DecrementIndent();
            sb.AppendLine("}");
        }

        ctx.AddSource(fileName, SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static bool IsValidSyntaxNodeForAugmentation(SyntaxNode node)
    {
        return node is PropertyDeclarationSyntax prop
               && prop.AttributeLists.Count != 0
               && prop.Modifiers.Any(SyntaxKind.PartialKeyword)
               // Skip if the property is readonly
               && (prop.AccessorList?.Accessors.Any(SyntaxKind.SetAccessorDeclaration) == true || prop.AccessorList?.Accessors.Any(SyntaxKind.InitAccessorDeclaration) == true);
    }

    private static PropertyAugmentationData? TransformPropertyDeclaration(GeneratorAttributeSyntaxContext syntaxContext)
    {
        if (syntaxContext.TargetSymbol is not IPropertySymbol propertySymbol)
        {
            return null;
        }

        var containingType = propertySymbol.ContainingType;
        var containingTypeNameStr = containingType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var propertyFullType = propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var namespaceName = containingType.ContainingNamespace.ToDisplayString();

        var propertyInitializer = propertySymbol.SetMethod?.IsInitOnly ?? false ? "init" : "set";

        var fileName = $"{containingTypeNameStr}_{propertySymbol.Name}_Augmented.g.cs";

        return new PropertyAugmentationData(
            fileName: fileName,
            containingTypeNameStr: containingTypeNameStr,
            propertyFullTypeStr: propertyFullType,
            propertyNameStr: propertySymbol.Name,
            namespaceNameStr: namespaceName,
            propertyInitializer: propertyInitializer);
    }
}